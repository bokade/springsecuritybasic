1. Username Uniqueness

InMemoryUserDetailsManager internally ek Map<String, UserDetails> rakhta hai.

username = key → unique hota hai.

Agar same username dobara add karte ho → purana overwrite ho jaata hai.
👉 Result: ek username = ek hi password & roles.

2. Defining Users (UserDetailsService)
@Bean
public UserDetailsService userDetailsService() {
    UserDetails user1 = User.withDefaultPasswordEncoder()
            .username("swapnil")
            .password("user123")
            .roles("USER")
            .build();

    UserDetails user2 = User.withDefaultPasswordEncoder()
            .username("admin")
            .password("admin123")
            .roles("ADMIN")
            .build();

    return new InMemoryUserDetailsManager(user1, user2);
}


User.withDefaultPasswordEncoder() → demo ke liye simple password encoder (plain text).

.username("...") → login username.

.password("...") → login password.

.roles("...") → user ke roles (Spring internally "ROLE_" prefix lagata hai).

new InMemoryUserDetailsManager(user1, user2) → do users memory me store ho gaye.

👉 Note: Real projects me users DB se aate hain (custom UserDetailsService).

3. Authentication Flow

User Postman / Browser form se deta hai:

username = swapnil
password = user123


Spring Security flow:

Call → userDetailsService.loadUserByUsername("swapnil")

Map se UserDetails object fetch hota hai.

Entered password vs stored password compare hota hai:
passwordEncoder.matches(entered, stored)

✅ Match → Authentication Success

❌ Mismatch → BadCredentialsException

4. Roles & Authorities

.roles("USER") → internally ROLE_USER

.roles("ADMIN") → internally ROLE_ADMIN

Ek user ke paas multiple roles bhi ho sakte hain.

👉 Access hamesha role ke prefix ke saath check hoti hai (ROLE_).

5. HttpSecurity (VERY IMPORTANT)

HttpSecurity ek configuration object hai jo batata hai web app ko kaise secure karna hai.

Ye internally FilterChain banata hai.

Builder Pattern use karta hai → isliye tum chain methods se easily rules define kar sakte ho.

🔹 Main kaam:

Kaunse endpoints secure karne hain (authorizeHttpRequests)

Kis role ko access milega (hasRole, hasAnyRole)

Authentication mechanism (httpBasic, formLogin, oauth2Login, etc.)

Extra security (CSRF, CORS, session management, etc.)

Example:

http.authorizeHttpRequests(auth -> auth
        .requestMatchers("/admin").hasRole("ADMIN")
        .requestMatchers("/user").hasAnyRole("USER","ADMIN")
        .anyRequest().authenticated()
    )
    .httpBasic();


👉 Yaha HttpSecurity ek builder hai jo SecurityFilterChain return karta hai.

5. SecurityFilterChain

Har request filter chain ke through jati hai.

Filter chain decide karti hai:

Kya authentication required hai?

Kya role/permission match kar raha hai?



6. HttpSecurity (Builder Pattern)

HttpSecurity = entry point for security config.

Builder style API → readable + step-by-step.

Example:

http.authorizeHttpRequests(auth -> auth
        .requestMatchers("/admin").hasRole("ADMIN")
        .requestMatchers("/user").hasAnyRole("USER","ADMIN")
        .anyRequest().authenticated()
    )
    .httpBasic();

7. Authorization Rules (Flow)

/admin → sirf ROLE_ADMIN

admin ✅

swapnil ❌ (403 Forbidden)

guest ❌ (401 Unauthorized)

/user → ROLE_USER ya ROLE_ADMIN

swapnil ✅

admin ✅

guest ❌ (401 Unauthorized)

others → login required

logged-in user ✅

guest ❌ (401 Unauthorized)

8. HTTP Basic Auth

Username/password request header me base64 encode hokar jata hai.

Browser/Postman prompt dikhata hai.

⚠️ Production me normally use nahi karte (only testing/demo).

9. Builder Pattern (General Concept)

Complex object ko step-by-step configure karne ka design pattern.

Example:

User user = User.withUsername("swapnil")
                .password("pass123")
                .roles("ADMIN")
                .build();


👉 Spring Security config (HttpSecurity) bhi isi tarah builder pattern use karta hai.

10. End-to-End Flow Recap
Client Request → SecurityFilterChain
       ↓
Authentication Check (username + password)
       ↓
   ✅ Success
       ↓
Authorization Rules (roles check)
       ↓
   ✅ Allowed → Controller executes
   ❌ Not allowed → 403 Forbidden

📌 Super Short Revision

Username → unique (map key)

Users → InMemoryUserDetailsManager (demo) ya DB (real)

Auth flow → loadUser → compare password → success/fail

Roles → always prefix ROLE_

FilterChain → har request check hoti hai

HttpSecurity → builder pattern

Rules:

/admin → ROLE_ADMIN

/user → ROLE_USER / ADMIN

others → login required

Flow → Authentication ✅ → Authorization ✅ → Access granted

👉 Suggestion:

Demo/test ke liye InMemoryUserDetailsManager use karo.

Real project me DB-based users + BCryptPasswordEncoder use karna.