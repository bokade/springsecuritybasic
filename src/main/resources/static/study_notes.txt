1. Username Uniqueness

InMemoryUserDetailsManager internally ek Map<String, UserDetails> rakhta hai.

username = key â†’ unique hota hai.

Agar same username dobara add karte ho â†’ purana overwrite ho jaata hai.
ğŸ‘‰ Result: ek username = ek hi password & roles.

2. Defining Users (UserDetailsService)
@Bean
public UserDetailsService userDetailsService() {
    UserDetails user1 = User.withDefaultPasswordEncoder()
            .username("swapnil")
            .password("user123")
            .roles("USER")
            .build();

    UserDetails user2 = User.withDefaultPasswordEncoder()
            .username("admin")
            .password("admin123")
            .roles("ADMIN")
            .build();

    return new InMemoryUserDetailsManager(user1, user2);
}


User.withDefaultPasswordEncoder() â†’ demo ke liye simple password encoder (plain text).

.username("...") â†’ login username.

.password("...") â†’ login password.

.roles("...") â†’ user ke roles (Spring internally "ROLE_" prefix lagata hai).

new InMemoryUserDetailsManager(user1, user2) â†’ do users memory me store ho gaye.

ğŸ‘‰ Note: Real projects me users DB se aate hain (custom UserDetailsService).

3. Authentication Flow

User Postman / Browser form se deta hai:

username = swapnil
password = user123


Spring Security flow:

Call â†’ userDetailsService.loadUserByUsername("swapnil")

Map se UserDetails object fetch hota hai.

Entered password vs stored password compare hota hai:
passwordEncoder.matches(entered, stored)

âœ… Match â†’ Authentication Success

âŒ Mismatch â†’ BadCredentialsException

4. Roles & Authorities

.roles("USER") â†’ internally ROLE_USER

.roles("ADMIN") â†’ internally ROLE_ADMIN

Ek user ke paas multiple roles bhi ho sakte hain.

ğŸ‘‰ Access hamesha role ke prefix ke saath check hoti hai (ROLE_).

5. HttpSecurity (VERY IMPORTANT)

HttpSecurity ek configuration object hai jo batata hai web app ko kaise secure karna hai.

Ye internally FilterChain banata hai.

Builder Pattern use karta hai â†’ isliye tum chain methods se easily rules define kar sakte ho.

ğŸ”¹ Main kaam:

Kaunse endpoints secure karne hain (authorizeHttpRequests)

Kis role ko access milega (hasRole, hasAnyRole)

Authentication mechanism (httpBasic, formLogin, oauth2Login, etc.)

Extra security (CSRF, CORS, session management, etc.)

Example:

http.authorizeHttpRequests(auth -> auth
        .requestMatchers("/admin").hasRole("ADMIN")
        .requestMatchers("/user").hasAnyRole("USER","ADMIN")
        .anyRequest().authenticated()
    )
    .httpBasic();


ğŸ‘‰ Yaha HttpSecurity ek builder hai jo SecurityFilterChain return karta hai.

5. SecurityFilterChain

Har request filter chain ke through jati hai.

Filter chain decide karti hai:

Kya authentication required hai?

Kya role/permission match kar raha hai?



6. HttpSecurity (Builder Pattern)

HttpSecurity = entry point for security config.

Builder style API â†’ readable + step-by-step.

Example:

http.authorizeHttpRequests(auth -> auth
        .requestMatchers("/admin").hasRole("ADMIN")
        .requestMatchers("/user").hasAnyRole("USER","ADMIN")
        .anyRequest().authenticated()
    )
    .httpBasic();

7. Authorization Rules (Flow)

/admin â†’ sirf ROLE_ADMIN

admin âœ…

swapnil âŒ (403 Forbidden)

guest âŒ (401 Unauthorized)

/user â†’ ROLE_USER ya ROLE_ADMIN

swapnil âœ…

admin âœ…

guest âŒ (401 Unauthorized)

others â†’ login required

logged-in user âœ…

guest âŒ (401 Unauthorized)

8. HTTP Basic Auth

Username/password request header me base64 encode hokar jata hai.

Browser/Postman prompt dikhata hai.

âš ï¸ Production me normally use nahi karte (only testing/demo).

9. Builder Pattern (General Concept)

Complex object ko step-by-step configure karne ka design pattern.

Example:

User user = User.withUsername("swapnil")
                .password("pass123")
                .roles("ADMIN")
                .build();


ğŸ‘‰ Spring Security config (HttpSecurity) bhi isi tarah builder pattern use karta hai.

10. End-to-End Flow Recap
Client Request â†’ SecurityFilterChain
       â†“
Authentication Check (username + password)
       â†“
   âœ… Success
       â†“
Authorization Rules (roles check)
       â†“
   âœ… Allowed â†’ Controller executes
   âŒ Not allowed â†’ 403 Forbidden

ğŸ“Œ Super Short Revision

Username â†’ unique (map key)

Users â†’ InMemoryUserDetailsManager (demo) ya DB (real)

Auth flow â†’ loadUser â†’ compare password â†’ success/fail

Roles â†’ always prefix ROLE_

FilterChain â†’ har request check hoti hai

HttpSecurity â†’ builder pattern

Rules:

/admin â†’ ROLE_ADMIN

/user â†’ ROLE_USER / ADMIN

others â†’ login required

Flow â†’ Authentication âœ… â†’ Authorization âœ… â†’ Access granted

ğŸ‘‰ Suggestion:

Demo/test ke liye InMemoryUserDetailsManager use karo.

Real project me DB-based users + BCryptPasswordEncoder use karna.


Major Authentication Mechanisms in Spring Security:
HTTP Basic : http.httpBasic();
Form Login : http.formLogin();
OAuth2 Login : http.oauth2Login();
JWT Token Authentication : http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
LDAP Authentication : http.ldapAuthentication();
API Key / Custom Token Authentication